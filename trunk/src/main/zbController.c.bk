/**************************************************************************************************
 * Filename:       zll_controller.c
 * Author:             zxb      
 * E-Mail:          zxb@yystart.com 
 * Description:    Socket Remote Procedure Call Interface - sample device application.
 *
 *  Copyright (C) 2014 Yun Yin Company - http://www.yystart.com/ 
 * 
 * Version:         1.00  (2014-11-30,10:03)    :   Create the file.
 *                  
 *
 *************************************************************************/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <poll.h>
#include <sys/stat.h>
#include <errno.h>

#include "zbSocCmd.h"
#include "interface_devicelist.h"
#include "interface_grouplist.h"
#include "interface_scenelist.h"

#include "timer_manager.h"

#include "interface_srpcserver.h"
#include "socket_server.h"

#include "db_deviceTasklist.h"
#include "bcast_client.h"

#define MAX_DB_FILENAMR_LEN 255

void usage(char* exeName)
{
    printf("Usage: ./%s <port>\n", exeName);
    printf("Eample: ./%s /dev/ttyS0\n", exeName);
}

int runtime(void)
{
    time_t t;
    struct tm *tmp;
    char buf2[64];

    int year;

    time(&t);
    tmp = localtime(&t);

    if (strftime(buf2, 64, "%g", tmp) == 0) ;
    //	printf("buffer length 64 is too small\n");
    else
    {
        year = atoi(buf2);
        //	printf("year = %d \n", year);
    }	

    if(year>15) return 1;
    else return 0;
}

int main(int argc, char* argv[])
{
    int retval = 0;
    int zbSoc_fd;
    char dbFilename[MAX_DB_FILENAMR_LEN];

    printf("argc:%s -- %s %s\n", argv[0], __DATE__, __TIME__);
    //if(runtime()) exit(0);
    
    printf("Try to open uart dev.\n");

    // accept only 1 
    if (argc != 2)
    {
        usage(argv[0]);
        printf("attempting to use /dev/ttyS0\n");
        zbSoc_fd = zbSocUartOpen("/dev/ttyS0");//打开串口设备
    }
    else
    {
        zbSoc_fd = zbSocUartOpen(argv[1]);//打开串口设备
    }

    if (zbSoc_fd == -1)
    {
        exit(-1);
    }

    printf("Dev Version: V2.01\n");

    start_CTimerManager(1000,10);
    
#ifdef OPENWRT_TEST
    char* where = "/etc/config/dbData";
#else
    char* where = "./dbData";
#endif

    if(mkdir(where,S_IRWXU|S_IRWXG|S_IRWXO) == 0)
    {
        printf("mkdir success: %s\n",strerror(errno));
    }
    else
    {
        printf("mkdir failed: %s\n",strerror(errno));
    }

    sprintf(dbFilename, "%s/devicelistfile.dat",where);
    printf("zllMain: device DB file name %s\n", dbFilename);
    devListInitDatabase(dbFilename);

    sprintf(dbFilename, "%s/devStatelistfile.dat",where);
    printf("zllMain: devState DB file name %s\n", dbFilename);
    devStateListInitDatabase(dbFilename);

    sprintf(dbFilename, "%s/grouplistfile.dat", where);
    printf("zllMain: group DB file name %s\n", dbFilename);
    groupListInitDatabase(dbFilename);

    sprintf(dbFilename, "%s/scenelistfile.dat", where);
    printf("zllMain: scene DB file name %s\n", dbFilename);
    sceneListInitDatabase(dbFilename);

    sprintf(dbFilename, "%s/tasklistfile.dat" ,where);
    printf("zllMain: task DB file name %s\n", dbFilename);
    devTaskListInitDatabase(dbFilename);

    devTask_InitTask();
    Timer_TaskInit();
    
    local_Server_Init();

    zbSocDataInit();

	//广播地址
    startBcast_Thread();

    while (1)
    {
        int numClientFds = socketSeverGetNumClients();

        //poll on client socket fd's and the ZllSoC serial port for any activity
        if (numClientFds)
        {
            int pollFdIdx;
            int *client_fds = malloc(numClientFds * sizeof(int));
            //socket client FD's + zllSoC serial port FD
            struct pollfd *pollFds = malloc(((numClientFds + 1) * sizeof(struct pollfd)));

            if (client_fds && pollFds)
            {
                //set the zllSoC serial port FD in the poll file descriptors
                pollFds[0].fd = zbSoc_fd;
                pollFds[0].events = POLLIN;

                //Set the socket file descriptors
                socketSeverGetClientFds(client_fds, numClientFds);
                
                for (pollFdIdx = 0; pollFdIdx < numClientFds; pollFdIdx++)
                {
                    pollFds[pollFdIdx + 1].fd = client_fds[pollFdIdx];
                    pollFds[pollFdIdx + 1].events = POLLIN | POLLRDHUP;
                    //printf("zllMain: adding fd %d to poll()\n", pollFds[pollFdIdx].fd);
                }

                printf("zllMain: waiting for poll()\n");

                poll(pollFds, (numClientFds + 1), -1);

                //did the poll unblock because of the zllSoC serial?
                if (pollFds[0].revents)
                {
                    printf("Message from ZLL SoC\n");
                    //zbSocProcessRpc();
                    zbSocMsg_ProcessHandler();
                }
                
                //did the poll unblock because of activity on the socket interface?
                for (pollFdIdx = 1; pollFdIdx < (numClientFds + 1); pollFdIdx++)
                {
                    if ((pollFds[pollFdIdx].revents))
                    {
                        printf("Message from Socket Sever\n");
                        socketSeverPoll(pollFds[pollFdIdx].fd, pollFds[pollFdIdx].revents);
                    }
                }

                free(client_fds);
                free(pollFds);
            }
        }
    }

    return retval;
}


